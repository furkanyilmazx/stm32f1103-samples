; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\ouput\hw_config.o --asm_dir=.\OUPUT\ --list_dir=.\OUPUT\ --depend=.\ouput\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\inc -I.\Libraries_USB_STDLIB\CMSIS\Device\ST\STM32F10x\Include -I.\Libraries_USB_STDLIB\STM32_USB-FS-Device_Driver\inc -I.\Libraries_USB_STDLIB\STM32F10x_StdPeriph_Driver\inc -I.\Libraries_USB_STDLIB\CMSIS\Include -I.\Libraries_USB_STDLIB\CMSIS\Device\ST\STM32F10x\Include -ID:\Development\Projects\EMBEDDED\STM32\STM32F103\stm32f1_projects\25-Touchy_USB_ADC_TIM\RTE -I"D:\Programs\Laptop\kurulu programlar\KEIL_V5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include" -I"D:\Programs\Laptop\kurulu programlar\KEIL_V5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\ouput\hw_config.crf src\hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;67     *******************************************************************************/
;;;68     void Enter_LowPowerMode(void)
000000  2003              MOVS     r0,#3
;;;69     {
;;;70       /* Set the device state to suspend */
;;;71       bDeviceState = SUSPENDED;
000002  4901              LDR      r1,|L1.8|
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;72     }
000006  4770              BX       lr
;;;73     
                          ENDP

                  |L1.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;133    *******************************************************************************/
;;;134    void Get_SerialNum(void)
000000  b570              PUSH     {r4-r6,lr}
;;;135    {
;;;136      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;137    
;;;138      Device_Serial0 = *(uint32_t*)ID1;
000002  480a              LDR      r0,|L2.44|
000004  6804              LDR      r4,[r0,#0]
;;;139      Device_Serial1 = *(uint32_t*)ID2;
000006  1d00              ADDS     r0,r0,#4
000008  6805              LDR      r5,[r0,#0]
;;;140      Device_Serial2 = *(uint32_t*)ID3;  
00000a  1d00              ADDS     r0,r0,#4
00000c  6806              LDR      r6,[r0,#0]
;;;141    
;;;142      Device_Serial0 += Device_Serial2;
00000e  4434              ADD      r4,r4,r6
;;;143    
;;;144      if (Device_Serial0 != 0)
000010  b154              CBZ      r4,|L2.40|
;;;145      {
;;;146        IntToUnicode (Device_Serial0, &Virtual_Com_Port_StringSerial[2] , 8);
000012  2208              MOVS     r2,#8
000014  4906              LDR      r1,|L2.48|
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       IntToUnicode
;;;147        IntToUnicode (Device_Serial1, &Virtual_Com_Port_StringSerial[18], 4);
00001c  2204              MOVS     r2,#4
00001e  4904              LDR      r1,|L2.48|
000020  3110              ADDS     r1,r1,#0x10
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       IntToUnicode
                  |L2.40|
;;;148      }
;;;149    }
000028  bd70              POP      {r4-r6,pc}
;;;150    
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      0x1ffff7e8
                  |L2.48|
                          DCD      Virtual_Com_Port_StringSerial+0x2

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=1

                  IntToUnicode PROC
;;;157    *******************************************************************************/
;;;158    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b530              PUSH     {r4,r5,lr}
;;;159    {
000002  460b              MOV      r3,r1
;;;160      uint8_t idx = 0;
000004  2100              MOVS     r1,#0
;;;161      
;;;162      for( idx = 0 ; idx < len ; idx ++)
000006  bf00              NOP      
000008  e016              B        |L3.56|
                  |L3.10|
;;;163      {
;;;164        if( ((value >> 28)) < 0xA )
00000a  240a              MOVS     r4,#0xa
00000c  ebb47f10          CMP      r4,r0,LSR #28
000010  d905              BLS      |L3.30|
;;;165        {
;;;166          pbuf[ 2* idx] = (value >> 28) + '0';
000012  2430              MOVS     r4,#0x30
000014  eb047410          ADD      r4,r4,r0,LSR #28
000018  f8034011          STRB     r4,[r3,r1,LSL #1]
00001c  e005              B        |L3.42|
                  |L3.30|
;;;167        }
;;;168        else
;;;169        {
;;;170          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
00001e  2441              MOVS     r4,#0x41
000020  eb047410          ADD      r4,r4,r0,LSR #28
000024  3c0a              SUBS     r4,r4,#0xa
000026  f8034011          STRB     r4,[r3,r1,LSL #1]
                  |L3.42|
;;;171        }
;;;172        
;;;173        value = value << 4;
00002a  0100              LSLS     r0,r0,#4
;;;174        
;;;175        pbuf[ 2* idx + 1] = 0;
00002c  2500              MOVS     r5,#0
00002e  004c              LSLS     r4,r1,#1
000030  1c64              ADDS     r4,r4,#1
000032  551d              STRB     r5,[r3,r4]
000034  1c4c              ADDS     r4,r1,#1              ;162
000036  b2e1              UXTB     r1,r4                 ;162
                  |L3.56|
000038  4291              CMP      r1,r2                 ;162
00003a  dbe6              BLT      |L3.10|
;;;176      }
;;;177    }
00003c  bd30              POP      {r4,r5,pc}
;;;178    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;79     *******************************************************************************/
;;;80     void Leave_LowPowerMode(void)
000000  b510              PUSH     {r4,lr}
;;;81     {
;;;82       DEVICE_INFO *pInfo = &Device_Info;
000002  4c06              LDR      r4,|L4.28|
;;;83     
;;;84       /* Set the device state to the correct state */
;;;85       if (pInfo->Current_Configuration != 0)
000004  7aa0              LDRB     r0,[r4,#0xa]
000006  b118              CBZ      r0,|L4.16|
;;;86       {
;;;87         /* Device configured */
;;;88         bDeviceState = CONFIGURED;
000008  2005              MOVS     r0,#5
00000a  4905              LDR      r1,|L4.32|
00000c  6008              STR      r0,[r1,#0]  ; bDeviceState
00000e  e002              B        |L4.22|
                  |L4.16|
;;;89       }
;;;90       else
;;;91       {
;;;92         bDeviceState = ATTACHED;
000010  2001              MOVS     r0,#1
000012  4903              LDR      r1,|L4.32|
000014  6008              STR      r0,[r1,#0]  ; bDeviceState
                  |L4.22|
;;;93       }
;;;94       /*Enable SystemCoreClock*/
;;;95       SystemInit();
000016  f7fffffe          BL       SystemInit
;;;96     }
00001a  bd10              POP      {r4,pc}
;;;97     
                          ENDP

                  |L4.28|
                          DCD      Device_Info
                  |L4.32|
                          DCD      bDeviceState

                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;34     *******************************************************************************/
;;;35     void Set_System(void)
000000  b510              PUSH     {r4,lr}
;;;36     {
;;;37     
;;;38       /* Configure the EXTI line 18 connected internally to the USB IP */
;;;39       EXTI_ClearITPendingBit(EXTI_Line18);
000002  f44f2080          MOV      r0,#0x40000
000006  f7fffffe          BL       EXTI_ClearITPendingBit
;;;40       EXTI_InitStructure.EXTI_Line = EXTI_Line18; 
00000a  f44f2080          MOV      r0,#0x40000
00000e  4905              LDR      r1,|L5.36|
000010  6008              STR      r0,[r1,#0]  ; EXTI_InitStructure
;;;41       EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
000012  2008              MOVS     r0,#8
000014  7148              STRB     r0,[r1,#5]
;;;42       EXTI_InitStructure.EXTI_LineCmd = ENABLE;
000016  2001              MOVS     r0,#1
000018  7188              STRB     r0,[r1,#6]
;;;43       EXTI_Init(&EXTI_InitStructure);
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       EXTI_Init
;;;44     }
000020  bd10              POP      {r4,pc}
;;;45     
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      EXTI_InitStructure

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;51     *******************************************************************************/
;;;52     void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;53     {
;;;54     
;;;55       /* Select USBCLK source */
;;;56       RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;57       
;;;58       /* Enable the USB clock */
;;;59       RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  05c8              LSLS     r0,r1,#23
00000c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;60     }
000010  bd10              POP      {r4,pc}
;;;61     
                          ENDP


                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;103    *******************************************************************************/
;;;104    void USB_Interrupts_Config(void)
000000  b508              PUSH     {r3,lr}
;;;105    {
;;;106      NVIC_InitTypeDef NVIC_InitStructure; 
;;;107      
;;;108      /* 2 bit for pre-emption priority, 2 bits for subpriority */
;;;109      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;110      
;;;111    
;;;112      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;113      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;114      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2000              MOVS     r0,#0
000018  f88d0002          STRB     r0,[sp,#2]
;;;115      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2001              MOVS     r0,#1
00001e  f88d0003          STRB     r0,[sp,#3]
;;;116      NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;117      
;;;118        /* Enable the USB Wake-up interrupt */
;;;119      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
000028  202a              MOVS     r0,#0x2a
00002a  f88d0000          STRB     r0,[sp,#0]
;;;120      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002e  2000              MOVS     r0,#0
000030  f88d0001          STRB     r0,[sp,#1]
;;;121      NVIC_Init(&NVIC_InitStructure);
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       NVIC_Init
;;;122    
;;;123    }
00003a  bd08              POP      {r3,pc}
;;;124    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  HSEStartUpStatus
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  EXTI_InitStructure
                          %        8
                  USB_Tx_State
00000c  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "src\\hw_config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_5eb6dadc____REV16|
#line 114 ".\\Libraries_USB_STDLIB\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_hw_config_c_5eb6dadc____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_5eb6dadc____REVSH|
#line 128
|__asm___11_hw_config_c_5eb6dadc____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
