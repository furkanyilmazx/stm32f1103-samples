; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\ouput\usb_pwr.o --asm_dir=.\OUPUT\ --list_dir=.\OUPUT\ --depend=.\ouput\usb_pwr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\inc -I.\Libraries_USB_STDLIB\CMSIS\Device\ST\STM32F10x\Include -I.\Libraries_USB_STDLIB\STM32_USB-FS-Device_Driver\inc -I.\Libraries_USB_STDLIB\STM32F10x_StdPeriph_Driver\inc -I.\Libraries_USB_STDLIB\CMSIS\Include -I.\Libraries_USB_STDLIB\CMSIS\Device\ST\STM32F10x\Include -ID:\Development\Projects\EMBEDDED\STM32\STM32F103\stm32f1_projects\25-Touchy_USB_ADC_TIM\RTE -I"D:\Programs\Laptop\kurulu programlar\KEIL_V5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include" -I"D:\Programs\Laptop\kurulu programlar\KEIL_V5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\ouput\usb_pwr.crf src\usb_pwr.c]
                          THUMB

                          AREA ||i.PowerOff||, CODE, READONLY, ALIGN=2

                  PowerOff PROC
;;;91     *******************************************************************************/
;;;92     RESULT PowerOff()
000000  2001              MOVS     r0,#1
;;;93     {
;;;94       /* disable all interrupts and force USB reset */
;;;95       _SetCNTR(CNTR_FRES);
000002  4905              LDR      r1,|L1.24|
000004  6008              STR      r0,[r1,#0]
;;;96       /* clear interrupt status register */
;;;97       _SetISTR(0);
000006  2000              MOVS     r0,#0
000008  1d09              ADDS     r1,r1,#4
00000a  6008              STR      r0,[r1,#0]
;;;98     
;;;99       /* switch-off device */
;;;100      _SetCNTR(CNTR_FRES + CNTR_PDWN);
00000c  2003              MOVS     r0,#3
00000e  1f09              SUBS     r1,r1,#4
000010  6008              STR      r0,[r1,#0]
;;;101      /* sw variables reset */
;;;102      /* ... */
;;;103    
;;;104      return USB_SUCCESS;
000012  2000              MOVS     r0,#0
;;;105    }
000014  4770              BX       lr
;;;106    
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      0x40005c40

                          AREA ||i.PowerOn||, CODE, READONLY, ALIGN=2

                  PowerOn PROC
;;;63     *******************************************************************************/
;;;64     RESULT PowerOn(void)
000000  2101              MOVS     r1,#1
;;;65     {
;;;66       uint16_t wRegVal;
;;;67     
;;;68     
;;;69       /*** CNTR_PWDN = 0 ***/
;;;70       wRegVal = CNTR_FRES;
;;;71       _SetCNTR(wRegVal);
000002  480b              LDR      r0,|L2.48|
000004  6001              STR      r1,[r0,#0]
;;;72     
;;;73       /*** CNTR_FRES = 0 ***/
;;;74       wInterrupt_Mask = 0;
000006  2000              MOVS     r0,#0
000008  4a0a              LDR      r2,|L2.52|
00000a  8010              STRH     r0,[r2,#0]
;;;75       _SetCNTR(wInterrupt_Mask);
00000c  4610              MOV      r0,r2
00000e  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
000010  4a07              LDR      r2,|L2.48|
000012  6010              STR      r0,[r2,#0]
;;;76       /*** Clear pending interrupts ***/
;;;77       _SetISTR(0);
000014  2000              MOVS     r0,#0
000016  1d12              ADDS     r2,r2,#4
000018  6010              STR      r0,[r2,#0]
;;;78       /*** Set interrupt mask ***/
;;;79       wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
00001a  f44f50e0          MOV      r0,#0x1c00
00001e  4a05              LDR      r2,|L2.52|
000020  8010              STRH     r0,[r2,#0]
;;;80       _SetCNTR(wInterrupt_Mask);
000022  4610              MOV      r0,r2
000024  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
000026  4a02              LDR      r2,|L2.48|
000028  6010              STR      r0,[r2,#0]
;;;81       
;;;82       return USB_SUCCESS;
00002a  2000              MOVS     r0,#0
;;;83     }
00002c  4770              BX       lr
;;;84     
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      0x40005c40
                  |L2.52|
                          DCD      wInterrupt_Mask

                          AREA ||i.Resume||, CODE, READONLY, ALIGN=2

                  Resume PROC
;;;255    *******************************************************************************/
;;;256    void Resume(RESUME_STATE eResumeSetVal)
000000  b570              PUSH     {r4-r6,lr}
;;;257    {
000002  4605              MOV      r5,r0
;;;258      uint16_t wCNTR;
;;;259    
;;;260      if (eResumeSetVal != RESUME_ESOF)
000004  2d07              CMP      r5,#7
000006  d001              BEQ      |L3.12|
;;;261        ResumeS.eState = eResumeSetVal;
000008  482e              LDR      r0,|L3.196|
00000a  7005              STRB     r5,[r0,#0]
                  |L3.12|
;;;262      switch (ResumeS.eState)
00000c  482d              LDR      r0,|L3.196|
00000e  7800              LDRB     r0,[r0,#0]  ; ResumeS
000010  2808              CMP      r0,#8
000012  d24e              BCS      |L3.178|
000014  e8dff000          TBB      [pc,r0]
000018  04111a20          DCB      0x04,0x11,0x1a,0x20
00001c  2b384e4f          DCB      0x2b,0x38,0x4e,0x4f
;;;263      {
;;;264        case RESUME_EXTERNAL:
;;;265          if (remotewakeupon ==0)
000020  4829              LDR      r0,|L3.200|
000022  6800              LDR      r0,[r0,#0]  ; remotewakeupon
000024  b928              CBNZ     r0,|L3.50|
;;;266          {
;;;267            Resume_Init();
000026  f7fffffe          BL       Resume_Init
;;;268            ResumeS.eState = RESUME_OFF;
00002a  2006              MOVS     r0,#6
00002c  4925              LDR      r1,|L3.196|
00002e  7008              STRB     r0,[r1,#0]
000030  e002              B        |L3.56|
                  |L3.50|
;;;269          }
;;;270          else /* RESUME detected during the RemoteWAkeup signalling => keep RemoteWakeup handling*/
;;;271          {
;;;272            ResumeS.eState = RESUME_ON;
000032  2005              MOVS     r0,#5
000034  4923              LDR      r1,|L3.196|
000036  7008              STRB     r0,[r1,#0]
                  |L3.56|
;;;273          }
;;;274          break;
000038  e041              B        |L3.190|
;;;275        case RESUME_INTERNAL:
;;;276          Resume_Init();
00003a  f7fffffe          BL       Resume_Init
;;;277          ResumeS.eState = RESUME_START;
00003e  2004              MOVS     r0,#4
000040  4920              LDR      r1,|L3.196|
000042  7008              STRB     r0,[r1,#0]
;;;278          remotewakeupon = 1;
000044  2001              MOVS     r0,#1
000046  4920              LDR      r1,|L3.200|
000048  6008              STR      r0,[r1,#0]  ; remotewakeupon
;;;279          break;
00004a  e038              B        |L3.190|
;;;280        case RESUME_LATER:
;;;281          ResumeS.bESOFcnt = 2;
00004c  2002              MOVS     r0,#2
00004e  491d              LDR      r1,|L3.196|
000050  7048              STRB     r0,[r1,#1]
;;;282          ResumeS.eState = RESUME_WAIT;
000052  2003              MOVS     r0,#3
000054  7008              STRB     r0,[r1,#0]
;;;283          break;
000056  e032              B        |L3.190|
;;;284        case RESUME_WAIT:
;;;285          ResumeS.bESOFcnt--;
000058  481a              LDR      r0,|L3.196|
00005a  7840              LDRB     r0,[r0,#1]  ; ResumeS
00005c  1e40              SUBS     r0,r0,#1
00005e  4919              LDR      r1,|L3.196|
000060  7048              STRB     r0,[r1,#1]
;;;286          if (ResumeS.bESOFcnt == 0)
000062  4608              MOV      r0,r1
000064  7840              LDRB     r0,[r0,#1]  ; ResumeS
000066  b908              CBNZ     r0,|L3.108|
;;;287            ResumeS.eState = RESUME_START;
000068  2004              MOVS     r0,#4
00006a  7008              STRB     r0,[r1,#0]
                  |L3.108|
;;;288          break;
00006c  e027              B        |L3.190|
;;;289        case RESUME_START:
;;;290          wCNTR = _GetCNTR();
00006e  4817              LDR      r0,|L3.204|
000070  6800              LDR      r0,[r0,#0]
000072  b284              UXTH     r4,r0
;;;291          wCNTR |= CNTR_RESUME;
000074  f0440410          ORR      r4,r4,#0x10
;;;292          _SetCNTR(wCNTR);
000078  4814              LDR      r0,|L3.204|
00007a  6004              STR      r4,[r0,#0]
;;;293          ResumeS.eState = RESUME_ON;
00007c  2005              MOVS     r0,#5
00007e  4911              LDR      r1,|L3.196|
000080  7008              STRB     r0,[r1,#0]
;;;294          ResumeS.bESOFcnt = 10;
000082  200a              MOVS     r0,#0xa
000084  7048              STRB     r0,[r1,#1]
;;;295          break;
000086  e01a              B        |L3.190|
;;;296        case RESUME_ON:    
;;;297          ResumeS.bESOFcnt--;
000088  480e              LDR      r0,|L3.196|
00008a  7840              LDRB     r0,[r0,#1]  ; ResumeS
00008c  1e40              SUBS     r0,r0,#1
00008e  490d              LDR      r1,|L3.196|
000090  7048              STRB     r0,[r1,#1]
;;;298          if (ResumeS.bESOFcnt == 0)
000092  4608              MOV      r0,r1
000094  7840              LDRB     r0,[r0,#1]  ; ResumeS
000096  b958              CBNZ     r0,|L3.176|
;;;299          {
;;;300            wCNTR = _GetCNTR();
000098  480c              LDR      r0,|L3.204|
00009a  6800              LDR      r0,[r0,#0]
00009c  b284              UXTH     r4,r0
;;;301            wCNTR &= (~CNTR_RESUME);
00009e  f0240410          BIC      r4,r4,#0x10
;;;302            _SetCNTR(wCNTR);
0000a2  480a              LDR      r0,|L3.204|
0000a4  6004              STR      r4,[r0,#0]
;;;303            ResumeS.eState = RESUME_OFF;
0000a6  2006              MOVS     r0,#6
0000a8  7008              STRB     r0,[r1,#0]
;;;304            remotewakeupon = 0;
0000aa  2000              MOVS     r0,#0
0000ac  4906              LDR      r1,|L3.200|
0000ae  6008              STR      r0,[r1,#0]  ; remotewakeupon
                  |L3.176|
;;;305          }
;;;306          break;
0000b0  e005              B        |L3.190|
                  |L3.178|
;;;307        case RESUME_OFF:
0000b2  bf00              NOP      
;;;308        case RESUME_ESOF:
0000b4  bf00              NOP      
;;;309        default:
;;;310          ResumeS.eState = RESUME_OFF;
0000b6  2006              MOVS     r0,#6
0000b8  4902              LDR      r1,|L3.196|
0000ba  7008              STRB     r0,[r1,#0]
;;;311          break;
0000bc  bf00              NOP      
                  |L3.190|
0000be  bf00              NOP                            ;274
;;;312      }
;;;313    }
0000c0  bd70              POP      {r4-r6,pc}
;;;314    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L3.196|
                          DCD      ResumeS
                  |L3.200|
                          DCD      remotewakeupon
                  |L3.204|
                          DCD      0x40005c40

                          AREA ||i.Resume_Init||, CODE, READONLY, ALIGN=2

                  Resume_Init PROC
;;;218    *******************************************************************************/
;;;219    void Resume_Init(void)
000000  b510              PUSH     {r4,lr}
;;;220    {
;;;221      uint16_t wCNTR;
;;;222      
;;;223      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;224      /* restart the clocks */
;;;225      /* ...  */
;;;226    
;;;227      /* CNTR_LPMODE = 0 */
;;;228      wCNTR = _GetCNTR();
000002  4807              LDR      r0,|L4.32|
000004  6800              LDR      r0,[r0,#0]
000006  b284              UXTH     r4,r0
;;;229      wCNTR &= (~CNTR_LPMODE);
000008  f0240404          BIC      r4,r4,#4
;;;230      _SetCNTR(wCNTR);    
00000c  4804              LDR      r0,|L4.32|
00000e  6004              STR      r4,[r0,#0]
;;;231      
;;;232      /* restore full power */
;;;233      /* ... on connected devices */
;;;234      Leave_LowPowerMode();
000010  f7fffffe          BL       Leave_LowPowerMode
;;;235    
;;;236      /* reset FSUSP bit */
;;;237      _SetCNTR(IMR_MSK);
000014  f44f403f          MOV      r0,#0xbf00
000018  4901              LDR      r1,|L4.32|
00001a  6008              STR      r0,[r1,#0]
;;;238    
;;;239      /* reverse suspend preparation */
;;;240      /* ... */ 
;;;241    
;;;242    }
00001c  bd10              POP      {r4,pc}
;;;243    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x40005c40

                          AREA ||i.Suspend||, CODE, READONLY, ALIGN=2

                  Suspend PROC
;;;113    *******************************************************************************/
;;;114    void Suspend(void)
000000  b538              PUSH     {r3-r5,lr}
;;;115    {
;;;116    	uint32_t i =0;
000002  2100              MOVS     r1,#0
;;;117    	uint16_t wCNTR;
;;;118    	uint32_t tmpreg = 0;
000004  2200              MOVS     r2,#0
;;;119      __IO uint32_t savePWR_CR=0;
000006  2300              MOVS     r3,#0
000008  9300              STR      r3,[sp,#0]
;;;120    	/* suspend preparation */
;;;121    	/* ... */
;;;122    	
;;;123    	/*Store CNTR value */
;;;124    	wCNTR = _GetCNTR();  
00000a  4b39              LDR      r3,|L5.240|
00000c  681b              LDR      r3,[r3,#0]
00000e  b298              UXTH     r0,r3
;;;125    
;;;126        /* This a sequence to apply a force RESET to handle a robustness case */
;;;127        
;;;128    	/*Store endpoints registers status */
;;;129        for (i=0;i<8;i++) EP[i] = _GetENDPOINT(i);
000010  bf00              NOP      
000012  e009              B        |L5.40|
                  |L5.20|
000014  4c37              LDR      r4,|L5.244|
000016  eb040381          ADD      r3,r4,r1,LSL #2
00001a  f8d33c00          LDR      r3,[r3,#0xc00]
00001e  b29b              UXTH     r3,r3
000020  4c35              LDR      r4,|L5.248|
000022  f8443021          STR      r3,[r4,r1,LSL #2]
000026  1c49              ADDS     r1,r1,#1
                  |L5.40|
000028  2908              CMP      r1,#8
00002a  d3f3              BCC      |L5.20|
;;;130    	
;;;131    	/* unmask RESET flag */
;;;132    	wCNTR|=CNTR_RESETM;
00002c  f4406080          ORR      r0,r0,#0x400
;;;133    	_SetCNTR(wCNTR);
000030  4b2f              LDR      r3,|L5.240|
000032  6018              STR      r0,[r3,#0]
;;;134    	
;;;135    	/*apply FRES */
;;;136    	wCNTR|=CNTR_FRES;
000034  f0400001          ORR      r0,r0,#1
;;;137    	_SetCNTR(wCNTR);
000038  6018              STR      r0,[r3,#0]
;;;138    	
;;;139    	/*clear FRES*/
;;;140    	wCNTR&=~CNTR_FRES;
00003a  f0200001          BIC      r0,r0,#1
;;;141    	_SetCNTR(wCNTR);
00003e  6018              STR      r0,[r3,#0]
;;;142    	
;;;143    	/*poll for RESET flag in ISTR*/
;;;144    	while((_GetISTR()&ISTR_RESET) == 0);
000040  bf00              NOP      
                  |L5.66|
000042  4b2b              LDR      r3,|L5.240|
000044  1d1b              ADDS     r3,r3,#4
000046  681b              LDR      r3,[r3,#0]
000048  f4036380          AND      r3,r3,#0x400
00004c  2b00              CMP      r3,#0
00004e  d0f8              BEQ      |L5.66|
;;;145    	
;;;146    	/* clear RESET flag in ISTR */
;;;147    	_SetISTR((uint16_t)CLR_RESET);
000050  f64f33ff          MOV      r3,#0xfbff
000054  4c26              LDR      r4,|L5.240|
000056  1d24              ADDS     r4,r4,#4
000058  6023              STR      r3,[r4,#0]
;;;148    	
;;;149    	/*restore Enpoints*/
;;;150    	for (i=0;i<8;i++)
00005a  2100              MOVS     r1,#0
00005c  e009              B        |L5.114|
                  |L5.94|
;;;151    	_SetENDPOINT(i, EP[i]);
00005e  4b26              LDR      r3,|L5.248|
000060  f8533021          LDR      r3,[r3,r1,LSL #2]
000064  b29b              UXTH     r3,r3
000066  4d23              LDR      r5,|L5.244|
000068  eb050481          ADD      r4,r5,r1,LSL #2
00006c  f8c43c00          STR      r3,[r4,#0xc00]
000070  1c49              ADDS     r1,r1,#1              ;150
                  |L5.114|
000072  2908              CMP      r1,#8                 ;150
000074  d3f3              BCC      |L5.94|
;;;152    	
;;;153    	/* Now it is safe to enter macrocell in suspend mode */
;;;154    	wCNTR |= CNTR_FSUSP;
000076  f0400008          ORR      r0,r0,#8
;;;155    	_SetCNTR(wCNTR);
00007a  4b1d              LDR      r3,|L5.240|
00007c  6018              STR      r0,[r3,#0]
;;;156    	
;;;157    	/* force low-power mode in the macrocell */
;;;158    	wCNTR = _GetCNTR();
00007e  681b              LDR      r3,[r3,#0]
000080  b298              UXTH     r0,r3
;;;159    	wCNTR |= CNTR_LPMODE;
000082  f0400004          ORR      r0,r0,#4
;;;160    	_SetCNTR(wCNTR);
000086  4b1a              LDR      r3,|L5.240|
000088  6018              STR      r0,[r3,#0]
;;;161    	
;;;162    	/*prepare entry in low power mode (STOP mode)*/
;;;163    	/* Select the regulator state in STOP mode*/
;;;164    	savePWR_CR = PWR->CR;
00008a  4b1c              LDR      r3,|L5.252|
00008c  681b              LDR      r3,[r3,#0]
00008e  9300              STR      r3,[sp,#0]
;;;165    	tmpreg = PWR->CR;
000090  4b1a              LDR      r3,|L5.252|
000092  681a              LDR      r2,[r3,#0]
;;;166    	/* Clear PDDS and LPDS bits */
;;;167    	tmpreg &= ((uint32_t)0xFFFFFFFC);
000094  f0220203          BIC      r2,r2,#3
;;;168    	/* Set LPDS bit according to PWR_Regulator value */
;;;169    	tmpreg |= PWR_Regulator_LowPower;
000098  f0420201          ORR      r2,r2,#1
;;;170    	/* Store the new value */
;;;171    	PWR->CR = tmpreg;
00009c  601a              STR      r2,[r3,#0]
;;;172    	/* Set SLEEPDEEP bit of Cortex System Control Register */
;;;173    #if defined (STM32F30X) || defined (STM32F37X)
;;;174            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
;;;175    #else
;;;176            SCB->SCR |= SCB_SCR_SLEEPDEEP;       
00009e  4b18              LDR      r3,|L5.256|
0000a0  681b              LDR      r3,[r3,#0]
0000a2  f0430304          ORR      r3,r3,#4
0000a6  4c16              LDR      r4,|L5.256|
0000a8  6023              STR      r3,[r4,#0]
;;;177    #endif
;;;178    	
;;;179    	/* enter system in STOP mode, only when wakeup flag in not set */
;;;180    	if((_GetISTR()&ISTR_WKUP)==0)
0000aa  4b11              LDR      r3,|L5.240|
0000ac  1d1b              ADDS     r3,r3,#4
0000ae  681b              LDR      r3,[r3,#0]
0000b0  f4035380          AND      r3,r3,#0x1000
0000b4  b933              CBNZ     r3,|L5.196|
;;;181    	{
;;;182    		__WFI();
0000b6  bf30              WFI      
;;;183    		/* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;184    #if defined (STM32F30X) || defined (STM32F37X)
;;;185                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk); 
;;;186    #else
;;;187                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP); 
0000b8  4623              MOV      r3,r4
0000ba  681b              LDR      r3,[r3,#0]
0000bc  f0230304          BIC      r3,r3,#4
0000c0  6023              STR      r3,[r4,#0]
0000c2  e014              B        |L5.238|
                  |L5.196|
;;;188    #endif
;;;189    	}
;;;190    	else
;;;191    	{
;;;192    		/* Clear Wakeup flag */
;;;193    		_SetISTR(CLR_WKUP);
0000c4  f64e73ff          MOV      r3,#0xefff
0000c8  4c09              LDR      r4,|L5.240|
0000ca  1d24              ADDS     r4,r4,#4
0000cc  6023              STR      r3,[r4,#0]
;;;194    		/* clear FSUSP to abort entry in suspend mode  */
;;;195            wCNTR = _GetCNTR();
0000ce  1f23              SUBS     r3,r4,#4
0000d0  681b              LDR      r3,[r3,#0]
0000d2  b298              UXTH     r0,r3
;;;196            wCNTR&=~CNTR_FSUSP;
0000d4  f0200008          BIC      r0,r0,#8
;;;197            _SetCNTR(wCNTR);
0000d8  1f23              SUBS     r3,r4,#4
0000da  6018              STR      r0,[r3,#0]
;;;198    		
;;;199    		/*restore sleep mode configuration */ 
;;;200    		/* restore Power regulator config in sleep mode*/
;;;201    		PWR->CR = savePWR_CR;
0000dc  4c07              LDR      r4,|L5.252|
0000de  9b00              LDR      r3,[sp,#0]
0000e0  6023              STR      r3,[r4,#0]
;;;202    		
;;;203    		/* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;204    #if defined (STM32F30X) || defined (STM32F37X)		
;;;205                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
;;;206    #else
;;;207                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);
0000e2  4b07              LDR      r3,|L5.256|
0000e4  681b              LDR      r3,[r3,#0]
0000e6  f0230304          BIC      r3,r3,#4
0000ea  4c05              LDR      r4,|L5.256|
0000ec  6023              STR      r3,[r4,#0]
                  |L5.238|
;;;208    #endif
;;;209        }
;;;210    }
0000ee  bd38              POP      {r3-r5,pc}
;;;211    
                          ENDP

                  |L5.240|
                          DCD      0x40005c40
                  |L5.244|
                          DCD      0x40005000
                  |L5.248|
                          DCD      ||EP||
                  |L5.252|
                          DCD      0x40007000
                  |L5.256|
                          DCD      0xe000ed10

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||EP||
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  bDeviceState
                          DCD      0x00000000
                  fSuspendEnabled
000004  01                DCB      0x01
                  ResumeS
000005  000000            DCB      0x00,0x00,0x00
                  remotewakeupon
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "src\\usb_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REV16|
#line 114 ".\\Libraries_USB_STDLIB\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_usb_pwr_c_e4e9521d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REVSH|
#line 128
|__asm___9_usb_pwr_c_e4e9521d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
