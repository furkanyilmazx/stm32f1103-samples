; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\ouput\usb_istr.o --asm_dir=.\OUPUT\ --list_dir=.\OUPUT\ --depend=.\ouput\usb_istr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\inc -I.\Libraries_USB_STDLIB\CMSIS\Device\ST\STM32F10x\Include -I.\Libraries_USB_STDLIB\STM32_USB-FS-Device_Driver\inc -I.\Libraries_USB_STDLIB\STM32F10x_StdPeriph_Driver\inc -I.\Libraries_USB_STDLIB\CMSIS\Include -I.\Libraries_USB_STDLIB\CMSIS\Device\ST\STM32F10x\Include -ID:\Development\Projects\EMBEDDED\STM32\STM32F103\stm32f1_projects\25-Touchy_USB_ADC_TIM\RTE -I"D:\Programs\Laptop\kurulu programlar\KEIL_V5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include" -I"D:\Programs\Laptop\kurulu programlar\KEIL_V5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\ouput\usb_istr.crf src\usb_istr.c]
                          THUMB

                          AREA ||i.USB_Istr||, CODE, READONLY, ALIGN=2

                  USB_Istr PROC
;;;76     *******************************************************************************/
;;;77     void USB_Istr(void)
000000  b510              PUSH     {r4,lr}
;;;78     {
000002  b088              SUB      sp,sp,#0x20
;;;79         uint32_t i=0;
000004  2400              MOVS     r4,#0
;;;80      __IO uint32_t EP[8];
;;;81       
;;;82       wIstr = _GetISTR();
000006  4869              LDR      r0,|L1.428|
000008  6800              LDR      r0,[r0,#0]
00000a  4969              LDR      r1,|L1.432|
00000c  8008              STRH     r0,[r1,#0]
;;;83     
;;;84     #if (IMR_MSK & ISTR_SOF)
;;;85       if (wIstr & ISTR_SOF & wInterrupt_Mask)
00000e  4608              MOV      r0,r1
000010  8800              LDRH     r0,[r0,#0]  ; wIstr
000012  f4007000          AND      r0,r0,#0x200
000016  4967              LDR      r1,|L1.436|
000018  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
00001a  4008              ANDS     r0,r0,r1
00001c  b150              CBZ      r0,|L1.52|
;;;86       {
;;;87         _SetISTR((uint16_t)CLR_SOF);
00001e  f64f50ff          MOV      r0,#0xfdff
000022  4962              LDR      r1,|L1.428|
000024  6008              STR      r0,[r1,#0]
;;;88         bIntPackSOF++;
000026  4864              LDR      r0,|L1.440|
000028  7800              LDRB     r0,[r0,#0]  ; bIntPackSOF
00002a  1c40              ADDS     r0,r0,#1
00002c  4962              LDR      r1,|L1.440|
00002e  7008              STRB     r0,[r1,#0]
;;;89     
;;;90     #ifdef SOF_CALLBACK
;;;91         SOF_Callback();
000030  f7fffffe          BL       SOF_Callback
                  |L1.52|
;;;92     #endif
;;;93       }
;;;94     #endif
;;;95       /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/  
;;;96       
;;;97     #if (IMR_MSK & ISTR_CTR)
;;;98       if (wIstr & ISTR_CTR & wInterrupt_Mask)
000034  485e              LDR      r0,|L1.432|
000036  8800              LDRH     r0,[r0,#0]  ; wIstr
000038  f4004000          AND      r0,r0,#0x8000
00003c  495d              LDR      r1,|L1.436|
00003e  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
000040  4008              ANDS     r0,r0,r1
000042  b108              CBZ      r0,|L1.72|
;;;99       {
;;;100        /* servicing of the endpoint correct transfer interrupt */
;;;101        /* clear of the CTR flag into the sub */
;;;102        CTR_LP();
000044  f7fffffe          BL       CTR_LP
                  |L1.72|
;;;103    #ifdef CTR_CALLBACK
;;;104        CTR_Callback();
;;;105    #endif
;;;106      }
;;;107    #endif
;;;108      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/  
;;;109    #if (IMR_MSK & ISTR_RESET)
;;;110      if (wIstr & ISTR_RESET & wInterrupt_Mask)
000048  4859              LDR      r0,|L1.432|
00004a  8800              LDRH     r0,[r0,#0]  ; wIstr
00004c  f4006080          AND      r0,r0,#0x400
000050  4958              LDR      r1,|L1.436|
000052  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
000054  4008              ANDS     r0,r0,r1
000056  b130              CBZ      r0,|L1.102|
;;;111      {
;;;112        _SetISTR((uint16_t)CLR_RESET);
000058  f64f30ff          MOV      r0,#0xfbff
00005c  4953              LDR      r1,|L1.428|
00005e  6008              STR      r0,[r1,#0]
;;;113        Device_Property.Reset();
000060  4956              LDR      r1,|L1.444|
000062  6848              LDR      r0,[r1,#4]  ; Device_Property
000064  4780              BLX      r0
                  |L1.102|
;;;114    #ifdef RESET_CALLBACK
;;;115        RESET_Callback();
;;;116    #endif
;;;117      }
;;;118    #endif
;;;119      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;120    #if (IMR_MSK & ISTR_DOVR)
;;;121      if (wIstr & ISTR_DOVR & wInterrupt_Mask)
;;;122      {
;;;123        _SetISTR((uint16_t)CLR_DOVR);
;;;124    #ifdef DOVR_CALLBACK
;;;125        DOVR_Callback();
;;;126    #endif
;;;127      }
;;;128    #endif
;;;129      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;130    #if (IMR_MSK & ISTR_ERR)
;;;131      if (wIstr & ISTR_ERR & wInterrupt_Mask)
000066  4852              LDR      r0,|L1.432|
000068  8800              LDRH     r0,[r0,#0]  ; wIstr
00006a  f4005000          AND      r0,r0,#0x2000
00006e  4951              LDR      r1,|L1.436|
000070  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
000072  4008              ANDS     r0,r0,r1
000074  b118              CBZ      r0,|L1.126|
;;;132      {
;;;133        _SetISTR((uint16_t)CLR_ERR);
000076  f64d70ff          MOV      r0,#0xdfff
00007a  494c              LDR      r1,|L1.428|
00007c  6008              STR      r0,[r1,#0]
                  |L1.126|
;;;134    #ifdef ERR_CALLBACK
;;;135        ERR_Callback();
;;;136    #endif
;;;137      }
;;;138    #endif
;;;139      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;140    #if (IMR_MSK & ISTR_WKUP)
;;;141      if (wIstr & ISTR_WKUP & wInterrupt_Mask)
00007e  484c              LDR      r0,|L1.432|
000080  8800              LDRH     r0,[r0,#0]  ; wIstr
000082  f4005080          AND      r0,r0,#0x1000
000086  494b              LDR      r1,|L1.436|
000088  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
00008a  4008              ANDS     r0,r0,r1
00008c  b130              CBZ      r0,|L1.156|
;;;142      {
;;;143        _SetISTR((uint16_t)CLR_WKUP);
00008e  f64e70ff          MOV      r0,#0xefff
000092  4946              LDR      r1,|L1.428|
000094  6008              STR      r0,[r1,#0]
;;;144        Resume(RESUME_EXTERNAL);
000096  2000              MOVS     r0,#0
000098  f7fffffe          BL       Resume
                  |L1.156|
;;;145    #ifdef WKUP_CALLBACK
;;;146        WKUP_Callback();
;;;147    #endif
;;;148      }
;;;149    #endif
;;;150      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;151    #if (IMR_MSK & ISTR_SUSP)
;;;152      if (wIstr & ISTR_SUSP & wInterrupt_Mask)
00009c  4844              LDR      r0,|L1.432|
00009e  8800              LDRH     r0,[r0,#0]  ; wIstr
0000a0  f4006000          AND      r0,r0,#0x800
0000a4  4943              LDR      r1,|L1.436|
0000a6  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
0000a8  4008              ANDS     r0,r0,r1
0000aa  b160              CBZ      r0,|L1.198|
;;;153      {
;;;154    
;;;155        /* check if SUSPEND is possible */
;;;156        if (fSuspendEnabled)
0000ac  4844              LDR      r0,|L1.448|
0000ae  7800              LDRB     r0,[r0,#0]  ; fSuspendEnabled
0000b0  b110              CBZ      r0,|L1.184|
;;;157        {
;;;158          Suspend();
0000b2  f7fffffe          BL       Suspend
0000b6  e002              B        |L1.190|
                  |L1.184|
;;;159        }
;;;160        else
;;;161        {
;;;162          /* if not possible then resume after xx ms */
;;;163          Resume(RESUME_LATER);
0000b8  2002              MOVS     r0,#2
0000ba  f7fffffe          BL       Resume
                  |L1.190|
;;;164        }
;;;165        /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
;;;166        _SetISTR((uint16_t)CLR_SUSP);
0000be  f24f70ff          MOV      r0,#0xf7ff
0000c2  493a              LDR      r1,|L1.428|
0000c4  6008              STR      r0,[r1,#0]
                  |L1.198|
;;;167    #ifdef SUSP_CALLBACK
;;;168        SUSP_Callback();
;;;169    #endif
;;;170      }
;;;171    #endif
;;;172      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;173    
;;;174    #if (IMR_MSK & ISTR_ESOF)
;;;175      if (wIstr & ISTR_ESOF & wInterrupt_Mask)
0000c6  483a              LDR      r0,|L1.432|
0000c8  8800              LDRH     r0,[r0,#0]  ; wIstr
0000ca  f4007080          AND      r0,r0,#0x100
0000ce  4939              LDR      r1,|L1.436|
0000d0  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
0000d2  4008              ANDS     r0,r0,r1
0000d4  2800              CMP      r0,#0
0000d6  d066              BEQ      |L1.422|
;;;176      {
;;;177        /* clear ESOF flag in ISTR */
;;;178        _SetISTR((uint16_t)CLR_ESOF);
0000d8  f64f60ff          MOV      r0,#0xfeff
0000dc  4933              LDR      r1,|L1.428|
0000de  6008              STR      r0,[r1,#0]
;;;179        
;;;180        if ((_GetFNR()&FNR_RXDP)!=0)
0000e0  1d08              ADDS     r0,r1,#4
0000e2  6800              LDR      r0,[r0,#0]
0000e4  f4004000          AND      r0,r0,#0x8000
0000e8  2800              CMP      r0,#0
0000ea  d056              BEQ      |L1.410|
;;;181        {
;;;182          /* increment ESOF counter */
;;;183          esof_counter ++;
0000ec  4835              LDR      r0,|L1.452|
0000ee  6800              LDR      r0,[r0,#0]  ; esof_counter
0000f0  1c40              ADDS     r0,r0,#1
0000f2  4934              LDR      r1,|L1.452|
0000f4  6008              STR      r0,[r1,#0]  ; esof_counter
;;;184          
;;;185          /* test if we enter in ESOF more than 3 times with FSUSP =0 and RXDP =1=>> possible missing SUSP flag*/
;;;186          if ((esof_counter >3)&&((_GetCNTR()&CNTR_FSUSP)==0))
0000f6  4608              MOV      r0,r1
0000f8  6800              LDR      r0,[r0,#0]  ; esof_counter
0000fa  2803              CMP      r0,#3
0000fc  d950              BLS      |L1.416|
0000fe  482b              LDR      r0,|L1.428|
000100  1f00              SUBS     r0,r0,#4
000102  6800              LDR      r0,[r0,#0]
000104  f0000008          AND      r0,r0,#8
000108  2800              CMP      r0,#0
00010a  d149              BNE      |L1.416|
;;;187          {           
;;;188            /* this a sequence to apply a force RESET*/
;;;189          
;;;190            /*Store CNTR value */
;;;191            wCNTR = _GetCNTR(); 
00010c  4827              LDR      r0,|L1.428|
00010e  1f00              SUBS     r0,r0,#4
000110  6800              LDR      r0,[r0,#0]
000112  b280              UXTH     r0,r0
000114  492c              LDR      r1,|L1.456|
000116  6008              STR      r0,[r1,#0]  ; wCNTR
;;;192          
;;;193            /*Store endpoints registers status */
;;;194            for (i=0;i<8;i++) EP[i] = _GetENDPOINT(i);
000118  2400              MOVS     r4,#0
00011a  e008              B        |L1.302|
                  |L1.284|
00011c  492b              LDR      r1,|L1.460|
00011e  eb010084          ADD      r0,r1,r4,LSL #2
000122  f8d00c00          LDR      r0,[r0,#0xc00]
000126  b280              UXTH     r0,r0
000128  f84d0024          STR      r0,[sp,r4,LSL #2]
00012c  1c64              ADDS     r4,r4,#1
                  |L1.302|
00012e  2c08              CMP      r4,#8
000130  d3f4              BCC      |L1.284|
;;;195          
;;;196            /*apply FRES */
;;;197            wCNTR|=CNTR_FRES;
000132  4825              LDR      r0,|L1.456|
000134  6800              LDR      r0,[r0,#0]  ; wCNTR
000136  f0400001          ORR      r0,r0,#1
00013a  4923              LDR      r1,|L1.456|
00013c  6008              STR      r0,[r1,#0]  ; wCNTR
;;;198            _SetCNTR(wCNTR);
00013e  4608              MOV      r0,r1
000140  6800              LDR      r0,[r0,#0]  ; wCNTR
000142  b280              UXTH     r0,r0
000144  4919              LDR      r1,|L1.428|
000146  1f09              SUBS     r1,r1,#4
000148  6008              STR      r0,[r1,#0]
;;;199     
;;;200            /*clear FRES*/
;;;201            wCNTR&=~CNTR_FRES;
00014a  481f              LDR      r0,|L1.456|
00014c  6800              LDR      r0,[r0,#0]  ; wCNTR
00014e  f0200001          BIC      r0,r0,#1
000152  491d              LDR      r1,|L1.456|
000154  6008              STR      r0,[r1,#0]  ; wCNTR
;;;202            _SetCNTR(wCNTR);
000156  4608              MOV      r0,r1
000158  6800              LDR      r0,[r0,#0]  ; wCNTR
00015a  b280              UXTH     r0,r0
00015c  4913              LDR      r1,|L1.428|
00015e  1f09              SUBS     r1,r1,#4
000160  6008              STR      r0,[r1,#0]
;;;203          
;;;204            /*poll for RESET flag in ISTR*/
;;;205            while((_GetISTR()&ISTR_RESET) == 0);
000162  bf00              NOP      
                  |L1.356|
000164  4811              LDR      r0,|L1.428|
000166  6800              LDR      r0,[r0,#0]
000168  f4006080          AND      r0,r0,#0x400
00016c  2800              CMP      r0,#0
00016e  d0f9              BEQ      |L1.356|
;;;206      
;;;207            /* clear RESET flag in ISTR */
;;;208            _SetISTR((uint16_t)CLR_RESET);
000170  f64f30ff          MOV      r0,#0xfbff
000174  490d              LDR      r1,|L1.428|
000176  6008              STR      r0,[r1,#0]
;;;209       
;;;210           /*restore Enpoints*/
;;;211            for (i=0;i<8;i++)
000178  2400              MOVS     r4,#0
00017a  e008              B        |L1.398|
                  |L1.380|
;;;212            _SetENDPOINT(i, EP[i]);
00017c  f85d0024          LDR      r0,[sp,r4,LSL #2]
000180  b280              UXTH     r0,r0
000182  4a12              LDR      r2,|L1.460|
000184  eb020184          ADD      r1,r2,r4,LSL #2
000188  f8c10c00          STR      r0,[r1,#0xc00]
00018c  1c64              ADDS     r4,r4,#1              ;211
                  |L1.398|
00018e  2c08              CMP      r4,#8                 ;211
000190  d3f4              BCC      |L1.380|
;;;213          
;;;214            esof_counter = 0;
000192  2000              MOVS     r0,#0
000194  490b              LDR      r1,|L1.452|
000196  6008              STR      r0,[r1,#0]  ; esof_counter
000198  e002              B        |L1.416|
                  |L1.410|
;;;215          }
;;;216        }
;;;217        else
;;;218        {
;;;219            esof_counter = 0;
00019a  2000              MOVS     r0,#0
00019c  4909              LDR      r1,|L1.452|
00019e  6008              STR      r0,[r1,#0]  ; esof_counter
                  |L1.416|
;;;220        }
;;;221        
;;;222        /* resume handling timing is made with ESOFs */
;;;223        Resume(RESUME_ESOF); /* request without change of the machine state */
0001a0  2007              MOVS     r0,#7
0001a2  f7fffffe          BL       Resume
                  |L1.422|
;;;224    
;;;225    #ifdef ESOF_CALLBACK
;;;226        ESOF_Callback();
;;;227    #endif
;;;228      }
;;;229    #endif
;;;230    } /* USB_Istr */
0001a6  b008              ADD      sp,sp,#0x20
0001a8  bd10              POP      {r4,pc}
;;;231    
                          ENDP

0001aa  0000              DCW      0x0000
                  |L1.428|
                          DCD      0x40005c44
                  |L1.432|
                          DCD      wIstr
                  |L1.436|
                          DCD      wInterrupt_Mask
                  |L1.440|
                          DCD      bIntPackSOF
                  |L1.444|
                          DCD      Device_Property
                  |L1.448|
                          DCD      fSuspendEnabled
                  |L1.452|
                          DCD      esof_counter
                  |L1.456|
                          DCD      wCNTR
                  |L1.460|
                          DCD      0x40005000

                          AREA ||.data||, DATA, ALIGN=2

                  wIstr
000000  0000              DCB      0x00,0x00
                  bIntPackSOF
000002  0000              DCB      0x00,0x00
                  esof_counter
                          DCD      0x00000000
                  wCNTR
                          DCD      0x00000000
                  pEpInt_IN
                          DCD      EP1_IN_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                  pEpInt_OUT
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      EP3_OUT_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process

;*** Start embedded assembler ***

#line 1 "src\\usb_istr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_istr_c_e9471872____REV16|
#line 114 ".\\Libraries_USB_STDLIB\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_usb_istr_c_e9471872____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_istr_c_e9471872____REVSH|
#line 128
|__asm___10_usb_istr_c_e9471872____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
