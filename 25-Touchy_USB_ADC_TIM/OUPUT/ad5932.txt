; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\ouput\ad5932.o --asm_dir=.\OUPUT\ --list_dir=.\OUPUT\ --depend=.\ouput\ad5932.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\inc -I.\Libraries_USB_STDLIB\CMSIS\Device\ST\STM32F10x\Include -I.\Libraries_USB_STDLIB\STM32_USB-FS-Device_Driver\inc -I.\Libraries_USB_STDLIB\STM32F10x_StdPeriph_Driver\inc -I.\Libraries_USB_STDLIB\CMSIS\Include -I.\Libraries_USB_STDLIB\CMSIS\Device\ST\STM32F10x\Include -ID:\Development\Projects\EMBEDDED\STM32\STM32F103\stm32f1_projects\25-Touchy_USB_ADC_TIM\RTE -I"D:\Programs\Laptop\kurulu programlar\KEIL_V5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include" -I"D:\Programs\Laptop\kurulu programlar\KEIL_V5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include" -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\ouput\ad5932.crf src\AD5932.c]
                          THUMB

                          AREA ||i.AD5932_Reset||, CODE, READONLY, ALIGN=2

                  AD5932_Reset PROC
;;;356    
;;;357    void AD5932_Reset()
000000  b510              PUSH     {r4,lr}
;;;358    {
;;;359    	GPIO_SetBits(AD5932_GPIOs, INTERRUPT_pin);
000002  2140              MOVS     r1,#0x40
000004  4805              LDR      r0,|L1.28|
000006  f7fffffe          BL       GPIO_SetBits
;;;360    	delay_MS(10);
00000a  200a              MOVS     r0,#0xa
00000c  f7fffffe          BL       delay_MS
;;;361    	GPIO_ResetBits(AD5932_GPIOs, INTERRUPT_pin);
000010  2140              MOVS     r1,#0x40
000012  4802              LDR      r0,|L1.28|
000014  f7fffffe          BL       GPIO_ResetBits
;;;362    }
000018  bd10              POP      {r4,pc}
;;;363    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40010800

                          AREA ||i.AD5932_Set_CR||, CODE, READONLY, ALIGN=2

                  AD5932_Set_CR PROC
;;;226    
;;;227    void AD5932_Set_CR(uint16_t B24_bit,uint16_t SinTri_bit, uint16_t MSBOUTEN_bit, uint16_t ext_INC_bit, uint16_t SYNCSEL_bit)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;228    {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  9f06              LDR      r7,[sp,#0x18]
;;;229    	
;;;230    	AD5932_Cr = AD5932_CR_base;					// Control registerina default başlangıç değerini atadık
00000e  20d3              MOVS     r0,#0xd3
000010  4922              LDR      r1,|L2.156|
000012  8008              STRH     r0,[r1,#0]
;;;231    	
;;;232    	if(B24_bit == AD5932_BIT24)
000014  f5b86f00          CMP      r8,#0x800
000018  d104              BNE      |L2.36|
;;;233    	{
;;;234    		AD5932_Cr |= AD5932_BIT24;				// B24 bitini aktif et
00001a  4608              MOV      r0,r1
00001c  8800              LDRH     r0,[r0,#0]  ; AD5932_Cr
00001e  f4406000          ORR      r0,r0,#0x800
000022  8008              STRH     r0,[r1,#0]
                  |L2.36|
;;;235    	}
;;;236    	
;;;237    	if(SinTri_bit == AD5932_SIN_OUT)
000024  f5b46fc0          CMP      r4,#0x600
000028  d106              BNE      |L2.56|
;;;238    	{
;;;239    		AD5932_Cr |= AD5932_SIN_OUT;			// Sinus çıkış ver	VOUT çıkışından
00002a  481c              LDR      r0,|L2.156|
00002c  8800              LDRH     r0,[r0,#0]  ; AD5932_Cr
00002e  f44060c0          ORR      r0,r0,#0x600
000032  491a              LDR      r1,|L2.156|
000034  8008              STRH     r0,[r1,#0]
000036  e008              B        |L2.74|
                  |L2.56|
;;;240    	}
;;;241    	else if(SinTri_bit == AD5932_TRI_OUT)
000038  f5b46f80          CMP      r4,#0x400
00003c  d105              BNE      |L2.74|
;;;242    	{
;;;243    		AD5932_Cr |= AD5932_TRI_OUT;			// Ucgen çıkış ver	VOUT çıkışından
00003e  4817              LDR      r0,|L2.156|
000040  8800              LDRH     r0,[r0,#0]  ; AD5932_Cr
000042  f4406080          ORR      r0,r0,#0x400
000046  4915              LDR      r1,|L2.156|
000048  8008              STRH     r0,[r1,#0]
                  |L2.74|
;;;244    	}
;;;245    		
;;;246    	if(MSBOUTEN_bit == AD5932_MSB_OUTEN)
00004a  f5b57f80          CMP      r5,#0x100
00004e  d105              BNE      |L2.92|
;;;247    	{
;;;248    		AD5932_Cr |= AD5932_MSB_OUTEN;			// Kare dalga  üret MSBOUT çıkışından
000050  4812              LDR      r0,|L2.156|
000052  8800              LDRH     r0,[r0,#0]  ; AD5932_Cr
000054  f4407080          ORR      r0,r0,#0x100
000058  4910              LDR      r1,|L2.156|
00005a  8008              STRH     r0,[r1,#0]
                  |L2.92|
;;;249    	}
;;;250    		
;;;251    	if(ext_INC_bit == AD5932_EXT_INC)
00005c  2e20              CMP      r6,#0x20
00005e  d105              BNE      |L2.108|
;;;252    	{
;;;253    		AD5932_Cr |= AD5932_EXT_INC;			// Frekans arttırımını dışarıdan kontrol et
000060  480e              LDR      r0,|L2.156|
000062  8800              LDRH     r0,[r0,#0]  ; AD5932_Cr
000064  f0400020          ORR      r0,r0,#0x20
000068  490c              LDR      r1,|L2.156|
00006a  8008              STRH     r0,[r1,#0]
                  |L2.108|
;;;254    	}
;;;255    		
;;;256    	if(SYNCSEL_bit == AD5932_SYNC_EOS)
00006c  2f0c              CMP      r7,#0xc
00006e  d106              BNE      |L2.126|
;;;257    	{
;;;258    		AD5932_Cr |= AD5932_SYNC_EOS;			// SYNOUT çıkışından her frekans taraması bittiğinde pulse al
000070  480a              LDR      r0,|L2.156|
000072  8800              LDRH     r0,[r0,#0]  ; AD5932_Cr
000074  f040000c          ORR      r0,r0,#0xc
000078  4908              LDR      r1,|L2.156|
00007a  8008              STRH     r0,[r1,#0]
00007c  e007              B        |L2.142|
                  |L2.126|
;;;259    	}
;;;260    	else if(SYNCSEL_bit == AD5932_SYNC_fINC)
00007e  2f04              CMP      r7,#4
000080  d105              BNE      |L2.142|
;;;261    	{
;;;262    		AD5932_Cr |= AD5932_SYNC_fINC;			// SYNCOUT çıkışından her frekans arttırımında 4xTclock süresinde pulse al
000082  4806              LDR      r0,|L2.156|
000084  8800              LDRH     r0,[r0,#0]  ; AD5932_Cr
000086  f0400004          ORR      r0,r0,#4
00008a  4904              LDR      r1,|L2.156|
00008c  8008              STRH     r0,[r1,#0]
                  |L2.142|
;;;263    	}
;;;264    								
;;;265    	sendCommand_AD5932(AD5932_Cr);				// paketlenen data yollanıyor
00008e  4803              LDR      r0,|L2.156|
000090  8800              LDRH     r0,[r0,#0]  ; AD5932_Cr
000092  f7fffffe          BL       sendCommand_AD5932
;;;266    							
;;;267    }
000096  e8bd81f0          POP      {r4-r8,pc}
;;;268    
                          ENDP

00009a  0000              DCW      0x0000
                  |L2.156|
                          DCD      AD5932_Cr

                          AREA ||i.AD5932_Set_Delta_F||, CODE, READONLY, ALIGN=2

                  AD5932_Set_Delta_F PROC
;;;287    
;;;288    int	AD5932_Set_Delta_F(uint32_t DeltaF_Data, uint8_t pORm)	// pORm: 1 ise pozitif, 0 ise negatif frekans artırımı
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;289    { 			
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;290    
;;;291    	uint16_t fLSB, fMSB;
;;;292    
;;;293    	DeltaF_Data =  MAX_24bit & DeltaF_Data;			// 24 bit maskeleme
000008  f024447f          BIC      r4,r4,#0xff000000
;;;294    	
;;;295    	fLSB =	0x00000FFF 	& DeltaF_Data;				// 24 bitin düşük anlamlı 12 bitini maskele 
00000c  f3c4070b          UBFX     r7,r4,#0,#12
;;;296    	fMSB = ((0x00FFF000 & DeltaF_Data) >> 12);		// 24 bitin yüksek anlamlı 12 bitini maskele
000010  480b              LDR      r0,|L3.64|
000012  4020              ANDS     r0,r0,r4
000014  0b06              LSRS     r6,r0,#12
;;;297    	
;;;298    	fLSB = fLSB | AD5932_DeltaF_LSB_base;			// deltaF registerının düşük anlamlı adresi ile "or"lanarak data paketleniyor.
000016  f4475700          ORR      r7,r7,#0x2000
;;;299    	
;;;300    	if(pORm == AD5932_positive_increment)
00001a  2d01              CMP      r5,#1
00001c  d102              BNE      |L3.36|
;;;301    	{	
;;;302    		fMSB = fMSB | AD5932_P_Delta_F_MSB_base;	// deltaF registerının yüksek anlamlı adresi ile "or"lanarak data paketleniyor.
00001e  f4465640          ORR      r6,r6,#0x3000
000022  e003              B        |L3.44|
                  |L3.36|
;;;303    	}
;;;304    	else if (pORm == AD5932_negative_increment)	
000024  2d02              CMP      r5,#2
000026  d101              BNE      |L3.44|
;;;305    	{
;;;306    		fMSB = fMSB | AD5932_M_Delta_F_MSB_base;	// deltaF registerının yüksek anlamlı adresi ile "or"lanarak data paketleniyor.
000028  f4465660          ORR      r6,r6,#0x3800
                  |L3.44|
;;;307    	}
;;;308    		
;;;309    	
;;;310    	sendCommand_AD5932(fLSB);						// paketlenen data yollanıyor
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       sendCommand_AD5932
;;;311    	sendCommand_AD5932(fMSB);						// paketlenen data yollanıyor
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       sendCommand_AD5932
;;;312    	
;;;313    	return 0;										// işlem başarılı
000038  2000              MOVS     r0,#0
;;;314    }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;315    
                          ENDP

00003e  0000              DCW      0x0000
                  |L3.64|
                          DCD      0x00fff000

                          AREA ||i.AD5932_Set_Inc_IntervalTime||, CODE, READONLY, ALIGN=2

                  AD5932_Set_Inc_IntervalTime PROC
;;;329    
;;;330    int AD5932_Set_Inc_IntervalTime(uint16_t Inc_int_type_bit, uint16_t Inc_IntTim_Data)
000000  b570              PUSH     {r4-r6,lr}
;;;331    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;332    	
;;;333    	if		(Inc_int_type_bit  == AD5932_tINT_fixWaveCycle)		AD5932_Inc_IntTim = AD5932_tINT_fixWaveCycle;
000006  f2440002          MOV      r0,#0x4002
00000a  4284              CMP      r4,r0
00000c  d102              BNE      |L4.20|
00000e  4915              LDR      r1,|L4.100|
000010  8008              STRH     r0,[r1,#0]
000012  e01a              B        |L4.74|
                  |L4.20|
;;;334    	else if	(Inc_int_type_bit  == AD5932_tINT_MCLK_DIV_1)		AD5932_Inc_IntTim = AD5932_tINT_MCLK_DIV_1;
000014  f2460002          MOV      r0,#0x6002
000018  4284              CMP      r4,r0
00001a  d102              BNE      |L4.34|
00001c  4911              LDR      r1,|L4.100|
00001e  8008              STRH     r0,[r1,#0]
000020  e013              B        |L4.74|
                  |L4.34|
;;;335    	else if	(Inc_int_type_bit  == AD5932_tINT_MCLK_DIV_5)		AD5932_Inc_IntTim = AD5932_tINT_MCLK_DIV_5;
000022  f6460002          MOV      r0,#0x6802
000026  4284              CMP      r4,r0
000028  d102              BNE      |L4.48|
00002a  490e              LDR      r1,|L4.100|
00002c  8008              STRH     r0,[r1,#0]
00002e  e00c              B        |L4.74|
                  |L4.48|
;;;336    	else if	(Inc_int_type_bit  == AD5932_tINT_MCLK_DIV_100)		AD5932_Inc_IntTim = AD5932_tINT_MCLK_DIV_100;
000030  f2470002          MOV      r0,#0x7002
000034  4284              CMP      r4,r0
000036  d102              BNE      |L4.62|
000038  490a              LDR      r1,|L4.100|
00003a  8008              STRH     r0,[r1,#0]
00003c  e005              B        |L4.74|
                  |L4.62|
;;;337    	else if	(Inc_int_type_bit  == AD5932_tINT_MCLK_DIV_500)		AD5932_Inc_IntTim = AD5932_tINT_MCLK_DIV_500;
00003e  f6470002          MOV      r0,#0x7802
000042  4284              CMP      r4,r0
000044  d101              BNE      |L4.74|
000046  4907              LDR      r1,|L4.100|
000048  8008              STRH     r0,[r1,#0]
                  |L4.74|
;;;338    	
;;;339    		
;;;340    	Inc_IntTim_Data &= MAX_11bit;					// 11 bitlik data maskeleme
00004a  f3c5050a          UBFX     r5,r5,#0,#11
;;;341    	
;;;342    	AD5932_Inc_IntTim |= Inc_IntTim_Data;			// maskelenen datanın incIntbase registeri ile paketleniyor
00004e  4805              LDR      r0,|L4.100|
000050  8800              LDRH     r0,[r0,#0]  ; AD5932_Inc_IntTim
000052  4328              ORRS     r0,r0,r5
000054  4903              LDR      r1,|L4.100|
000056  8008              STRH     r0,[r1,#0]
;;;343    		
;;;344    	sendCommand_AD5932(AD5932_Inc_IntTim);			// paketlenen data yollanıyor
000058  4608              MOV      r0,r1
00005a  8800              LDRH     r0,[r0,#0]  ; AD5932_Inc_IntTim
00005c  f7fffffe          BL       sendCommand_AD5932
;;;345    	
;;;346    	return 0;
000060  2000              MOVS     r0,#0
;;;347    }
000062  bd70              POP      {r4-r6,pc}
;;;348    
                          ENDP

                  |L4.100|
                          DCD      AD5932_Inc_IntTim

                          AREA ||i.AD5932_Set_NumOfInc||, CODE, READONLY, ALIGN=2

                  AD5932_Set_NumOfInc PROC
;;;315    
;;;316    int AD5932_Set_NumOfInc(uint16_t Inc_Num_Data)
000000  b510              PUSH     {r4,lr}
;;;317    {
000002  4604              MOV      r4,r0
;;;318    
;;;319    	AD5932_NumOfInc = AD5932_NUM_INC_base;
000004  f2410002          MOV      r0,#0x1002
000008  4906              LDR      r1,|L5.36|
00000a  8008              STRH     r0,[r1,#0]
;;;320    	
;;;321    	Inc_Num_Data &= MAX_12bit;						//	12 bit maskeleme
00000c  f3c4040b          UBFX     r4,r4,#0,#12
;;;322    	
;;;323    	AD5932_NumOfInc |= Inc_Num_Data;			// Paketle
000010  4608              MOV      r0,r1
000012  8800              LDRH     r0,[r0,#0]  ; AD5932_NumOfInc
000014  4320              ORRS     r0,r0,r4
000016  8008              STRH     r0,[r1,#0]
;;;324    	
;;;325    	sendCommand_AD5932(AD5932_NumOfInc);		// paketlenen data yollanıyor
000018  4608              MOV      r0,r1
00001a  8800              LDRH     r0,[r0,#0]  ; AD5932_NumOfInc
00001c  f7fffffe          BL       sendCommand_AD5932
;;;326    	
;;;327    	return 0;
000020  2000              MOVS     r0,#0
;;;328    }
000022  bd10              POP      {r4,pc}
;;;329    
                          ENDP

                  |L5.36|
                          DCD      AD5932_NumOfInc

                          AREA ||i.AD5932_Set_Start_Freq||, CODE, READONLY, ALIGN=2

                  AD5932_Set_Start_Freq PROC
;;;268    
;;;269    int AD5932_Set_Start_Freq(uint32_t Freq_Data)
000000  b570              PUSH     {r4-r6,lr}
;;;270    {
000002  4604              MOV      r4,r0
;;;271    	uint16_t fLSB, fMSB;
;;;272    	
;;;273    	Freq_Data =  MAX_24bit & Freq_Data;				// 24 bit maskeleme
000004  f024447f          BIC      r4,r4,#0xff000000
;;;274    	
;;;275    	fLSB = 0x00000FFF 	& Freq_Data;				// 24 bitin düşük anlamlı 12 bitini maskele 
000008  f3c4050b          UBFX     r5,r4,#0,#12
;;;276    	fMSB = ((0x00FFF000 & Freq_Data) >> 12);		// 24 bitin yüksek anlamlı 12 bitini maskele
00000c  4807              LDR      r0,|L6.44|
00000e  4020              ANDS     r0,r0,r4
000010  0b06              LSRS     r6,r0,#12
;;;277    	
;;;278    	fLSB = fLSB | 0xC000;							// Fstart registerının düşük anlamlı adresi ile "or"lanarak data paketleniyor.
000012  f4454540          ORR      r5,r5,#0xc000
;;;279    	fMSB = fMSB | 0xD000;							// Fstart registerının yüksek anlamlı adresi ile "or"lanarak data paketleniyor.
000016  f4464650          ORR      r6,r6,#0xd000
;;;280    	
;;;281    	sendCommand_AD5932(fLSB);						// paketlenen data yollanıyor
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       sendCommand_AD5932
;;;282    	sendCommand_AD5932(fMSB);						// paketlenen data yollanıyor
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       sendCommand_AD5932
;;;283    	
;;;284    	return 0;										// işlem başarılı
000026  2000              MOVS     r0,#0
;;;285    
;;;286    }
000028  bd70              POP      {r4-r6,pc}
;;;287    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x00fff000

                          AREA ||i.AD5932_Standby||, CODE, READONLY, ALIGN=2

                  AD5932_Standby PROC
;;;363    
;;;364    void AD5932_Standby()
000000  b510              PUSH     {r4,lr}
;;;365    {
;;;366    	AD5932_Reset();
000002  f7fffffe          BL       AD5932_Reset
;;;367    	GPIO_SetBits(AD5932_GPIOs, STANDBY_pin);
000006  2110              MOVS     r1,#0x10
000008  4801              LDR      r0,|L7.16|
00000a  f7fffffe          BL       GPIO_SetBits
;;;368    }
00000e  bd10              POP      {r4,pc}
;;;369    
                          ENDP

                  |L7.16|
                          DCD      0x40010800

                          AREA ||i.AD5932_Start_Sweep||, CODE, READONLY, ALIGN=2

                  AD5932_Start_Sweep PROC
;;;348    
;;;349    void AD5932_Start_Sweep()
000000  b510              PUSH     {r4,lr}
;;;350    {
;;;351    	delay_MS(10);
000002  200a              MOVS     r0,#0xa
000004  f7fffffe          BL       delay_MS
;;;352    	GPIO_SetBits(AD5932_GPIOs, CTRL_pin);
000008  2120              MOVS     r1,#0x20
00000a  4805              LDR      r0,|L8.32|
00000c  f7fffffe          BL       GPIO_SetBits
;;;353    	delay_MS(10);
000010  200a              MOVS     r0,#0xa
000012  f7fffffe          BL       delay_MS
;;;354    	GPIO_ResetBits(AD5932_GPIOs, CTRL_pin);
000016  2120              MOVS     r1,#0x20
000018  4801              LDR      r0,|L8.32|
00001a  f7fffffe          BL       GPIO_ResetBits
;;;355    }
00001e  bd10              POP      {r4,pc}
;;;356    
                          ENDP

                  |L8.32|
                          DCD      0x40010800

                          AREA ||i.AD5932_Wakeup||, CODE, READONLY, ALIGN=2

                  AD5932_Wakeup PROC
;;;369    
;;;370    void AD5932_Wakeup()
000000  b510              PUSH     {r4,lr}
;;;371    {
;;;372    	GPIO_ResetBits(AD5932_GPIOs, STANDBY_pin);
000002  2110              MOVS     r1,#0x10
000004  4801              LDR      r0,|L9.12|
000006  f7fffffe          BL       GPIO_ResetBits
;;;373    }
00000a  bd10              POP      {r4,pc}
                          ENDP

                  |L9.12|
                          DCD      0x40010800

                          AREA ||i.TIM2_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM2_IRQHandler PROC
;;;138    
;;;139    void TIM2_IRQHandler()
000000  b510              PUSH     {r4,lr}
;;;140    {
;;;141    
;;;142    	if(TIM_GetFlagStatus(TIM2,TIM_FLAG_Update) == SET)
000002  2101              MOVS     r1,#1
000004  0788              LSLS     r0,r1,#30
000006  f7fffffe          BL       TIM_GetFlagStatus
00000a  2801              CMP      r0,#1
00000c  d145              BNE      |L10.154|
;;;143    	{
;;;144    			
;;;145    		adc_value = ADC_GetConversionValue(ADC1);
00000e  4823              LDR      r0,|L10.156|
000010  f7fffffe          BL       ADC_GetConversionValue
000014  4922              LDR      r1,|L10.160|
000016  8008              STRH     r0,[r1,#0]
;;;146    		
;;;147    		if(buffer_counter < 16)
000018  4822              LDR      r0,|L10.164|
00001a  7800              LDRB     r0,[r0,#0]  ; buffer_counter
00001c  2810              CMP      r0,#0x10
00001e  da29              BGE      |L10.116|
;;;148    		{
;;;149    			buffer[(buffer_counter*4)+0] = ((((adc_value)>>8)&0x000F)+65);
000020  4608              MOV      r0,r1
000022  8800              LDRH     r0,[r0,#0]  ; adc_value
000024  f3c02003          UBFX     r0,r0,#8,#4
000028  3041              ADDS     r0,r0,#0x41
00002a  491e              LDR      r1,|L10.164|
00002c  7809              LDRB     r1,[r1,#0]  ; buffer_counter
00002e  2200              MOVS     r2,#0
000030  eb020181          ADD      r1,r2,r1,LSL #2
000034  4a1c              LDR      r2,|L10.168|
000036  5450              STRB     r0,[r2,r1]
;;;150    			buffer[(buffer_counter*4)+1] = ((((adc_value)>>4)&0x000F)+65);
000038  4819              LDR      r0,|L10.160|
00003a  8800              LDRH     r0,[r0,#0]  ; adc_value
00003c  f3c01003          UBFX     r0,r0,#4,#4
000040  3041              ADDS     r0,r0,#0x41
000042  4918              LDR      r1,|L10.164|
000044  7809              LDRB     r1,[r1,#0]  ; buffer_counter
000046  2201              MOVS     r2,#1
000048  eb020181          ADD      r1,r2,r1,LSL #2
00004c  4a16              LDR      r2,|L10.168|
00004e  5450              STRB     r0,[r2,r1]
;;;151    			buffer[(buffer_counter*4)+2] = ((((adc_value))&0x000F)+65);
000050  4813              LDR      r0,|L10.160|
000052  8800              LDRH     r0,[r0,#0]  ; adc_value
000054  f000000f          AND      r0,r0,#0xf
000058  3041              ADDS     r0,r0,#0x41
00005a  4912              LDR      r1,|L10.164|
00005c  7809              LDRB     r1,[r1,#0]  ; buffer_counter
00005e  2202              MOVS     r2,#2
000060  eb020181          ADD      r1,r2,r1,LSL #2
000064  4a10              LDR      r2,|L10.168|
000066  5450              STRB     r0,[r2,r1]
;;;152    			buffer_counter++;
000068  480e              LDR      r0,|L10.164|
00006a  7800              LDRB     r0,[r0,#0]  ; buffer_counter
00006c  1c40              ADDS     r0,r0,#1
00006e  490d              LDR      r1,|L10.164|
000070  7008              STRB     r0,[r1,#0]
000072  e00e              B        |L10.146|
                  |L10.116|
;;;153    		}
;;;154    		else
;;;155    		{
;;;156    			UserToPMABufferCopy(buffer, ENDP1_TXADDR, 64);
000074  2240              MOVS     r2,#0x40
000076  21c0              MOVS     r1,#0xc0
000078  480b              LDR      r0,|L10.168|
00007a  f7fffffe          BL       UserToPMABufferCopy
;;;157    			SetEPTxCount(ENDP1, 64);
00007e  2140              MOVS     r1,#0x40
000080  2001              MOVS     r0,#1
000082  f7fffffe          BL       SetEPTxCount
;;;158    			SetEPTxValid(ENDP1); 
000086  2001              MOVS     r0,#1
000088  f7fffffe          BL       SetEPTxValid
;;;159    			buffer_counter = 0;
00008c  2000              MOVS     r0,#0
00008e  4905              LDR      r1,|L10.164|
000090  7008              STRB     r0,[r1,#0]
                  |L10.146|
;;;160    		}
;;;161    		
;;;162    
;;;163    		TIM_ClearFlag(TIM2,TIM_FLAG_Update);
000092  2101              MOVS     r1,#1
000094  0788              LSLS     r0,r1,#30
000096  f7fffffe          BL       TIM_ClearFlag
                  |L10.154|
;;;164    	}
;;;165    }
00009a  bd10              POP      {r4,pc}
;;;166    
                          ENDP

                  |L10.156|
                          DCD      0x40012400
                  |L10.160|
                          DCD      adc_value
                  |L10.164|
                          DCD      buffer_counter
                  |L10.168|
                          DCD      buffer

                          AREA ||i.delay_MS||, CODE, READONLY, ALIGN=2

                  delay_MS PROC
;;;11     
;;;12     void delay_MS(uint32_t nCount)
000000  4a06              LDR      r2,|L11.28|
;;;13     { 
;;;14     	uint32_t i;
;;;15     	nCount = nCount*(SystemCoreClock/5000);
000002  6812              LDR      r2,[r2,#0]  ; SystemCoreClock
000004  f2413388          MOV      r3,#0x1388
000008  fbb2f2f3          UDIV     r2,r2,r3
00000c  4350              MULS     r0,r2,r0
;;;16     	for(i=0;i<nCount;i++);
00000e  2100              MOVS     r1,#0
000010  e000              B        |L11.20|
                  |L11.18|
000012  1c49              ADDS     r1,r1,#1
                  |L11.20|
000014  4281              CMP      r1,r0
000016  d3fc              BCC      |L11.18|
;;;17     }
000018  4770              BX       lr
;;;18     
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      SystemCoreClock

                          AREA ||i.init_AD5932_GPIO||, CODE, READONLY, ALIGN=2

                  init_AD5932_GPIO PROC
;;;202    
;;;203    void init_AD5932_GPIO()
000000  b508              PUSH     {r3,lr}
;;;204    {
;;;205    	GPIO_InitTypeDef 	GPIO_InitStruct;
;;;206    	
;;;207    	GPIO_InitStruct.GPIO_Pin = STANDBY_pin | CTRL_pin | INTERRUPT_pin;
000002  2070              MOVS     r0,#0x70
000004  f8ad0000          STRH     r0,[sp,#0]
;;;208    	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;
000008  2010              MOVS     r0,#0x10
00000a  f88d0003          STRB     r0,[sp,#3]
;;;209    	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
00000e  2003              MOVS     r0,#3
000010  f88d0002          STRB     r0,[sp,#2]
;;;210    	
;;;211    	GPIO_Init(GPIOA, &GPIO_InitStruct);
000014  4669              MOV      r1,sp
000016  480e              LDR      r0,|L12.80|
000018  f7fffffe          BL       GPIO_Init
;;;212    	
;;;213    	/* SPI2 CS pin configuration */
;;;214    	GPIO_InitStruct.GPIO_Pin 	= SPI2_CS;
00001c  f44f5080          MOV      r0,#0x1000
000020  f8ad0000          STRH     r0,[sp,#0]
;;;215    	
;;;216    	GPIO_Init(SPI2_GPIO, &GPIO_InitStruct);	
000024  4669              MOV      r1,sp
000026  480b              LDR      r0,|L12.84|
000028  f7fffffe          BL       GPIO_Init
;;;217    	
;;;218    	// AD5932 pin initialize values
;;;219    	GPIO_SetBits(SPI2_GPIO, SPI2_CS);
00002c  f44f5180          MOV      r1,#0x1000
000030  4808              LDR      r0,|L12.84|
000032  f7fffffe          BL       GPIO_SetBits
;;;220    	GPIO_ResetBits(AD5932_GPIOs, CTRL_pin);
000036  2120              MOVS     r1,#0x20
000038  4805              LDR      r0,|L12.80|
00003a  f7fffffe          BL       GPIO_ResetBits
;;;221    	GPIO_ResetBits(AD5932_GPIOs, STANDBY_pin);
00003e  2110              MOVS     r1,#0x10
000040  4803              LDR      r0,|L12.80|
000042  f7fffffe          BL       GPIO_ResetBits
;;;222    	GPIO_ResetBits(AD5932_GPIOs, INTERRUPT_pin);
000046  2140              MOVS     r1,#0x40
000048  4801              LDR      r0,|L12.80|
00004a  f7fffffe          BL       GPIO_ResetBits
;;;223    	
;;;224    
;;;225    }
00004e  bd08              POP      {r3,pc}
;;;226    
                          ENDP

                  |L12.80|
                          DCD      0x40010800
                  |L12.84|
                          DCD      0x40010c00

                          AREA ||i.init_ADC_for_AD5932||, CODE, READONLY, ALIGN=2

                  init_ADC_for_AD5932 PROC
;;;57     
;;;58     void init_ADC_for_AD5932()
000000  b510              PUSH     {r4,lr}
;;;59     {
000002  b086              SUB      sp,sp,#0x18
;;;60     	int i;
;;;61     	
;;;62     	ADC_InitTypeDef adc_struct;
;;;63     	GPIO_InitTypeDef 	GPIO_InitStruct;
;;;64     
;;;65     	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;
000004  2001              MOVS     r0,#1
000006  f8ad0000          STRH     r0,[sp,#0]
;;;66     	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;
00000a  2000              MOVS     r0,#0
00000c  f88d0003          STRB     r0,[sp,#3]
;;;67     
;;;68     	GPIO_Init(GPIOA, &GPIO_InitStruct);
000010  4669              MOV      r1,sp
000012  4820              LDR      r0,|L13.148|
000014  f7fffffe          BL       GPIO_Init
;;;69     
;;;70     	adc_struct.ADC_Mode = ADC_Mode_Independent;
000018  2000              MOVS     r0,#0
00001a  9001              STR      r0,[sp,#4]
;;;71     	adc_struct.ADC_ContinuousConvMode = ENABLE;	// sürekli çevrim
00001c  2001              MOVS     r0,#1
00001e  f88d0009          STRB     r0,[sp,#9]
;;;72     	adc_struct.ADC_ScanConvMode = DISABLE;		// tek kanal ADC
000022  2000              MOVS     r0,#0
000024  f88d0008          STRB     r0,[sp,#8]
;;;73     	adc_struct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;	// dış tetiklemeli olmayacak
000028  f44f2060          MOV      r0,#0xe0000
00002c  9003              STR      r0,[sp,#0xc]
;;;74     	adc_struct.ADC_DataAlign = ADC_DataAlign_Right;
00002e  2000              MOVS     r0,#0
000030  9004              STR      r0,[sp,#0x10]
;;;75     	adc_struct.ADC_NbrOfChannel = ADC_Channel_1;
000032  2001              MOVS     r0,#1
000034  f88d0014          STRB     r0,[sp,#0x14]
;;;76     
;;;77     	ADC_Init(ADC1,&adc_struct);
000038  a901              ADD      r1,sp,#4
00003a  4817              LDR      r0,|L13.152|
00003c  f7fffffe          BL       ADC_Init
;;;78     	ADC_RegularChannelConfig(ADC1, ADC_Channel_1,1,ADC_SampleTime_1Cycles5);
000040  2300              MOVS     r3,#0
000042  2201              MOVS     r2,#1
000044  4611              MOV      r1,r2
000046  4814              LDR      r0,|L13.152|
000048  f7fffffe          BL       ADC_RegularChannelConfig
;;;79     
;;;80     	//	ADC_ITConfig(ADC1,ADC_IT_EOC,ENABLE);
;;;81     	ADC_Cmd(ADC1,ENABLE);
00004c  2101              MOVS     r1,#1
00004e  4812              LDR      r0,|L13.152|
000050  f7fffffe          BL       ADC_Cmd
;;;82     
;;;83     	ADC_ResetCalibration(ADC1);
000054  4810              LDR      r0,|L13.152|
000056  f7fffffe          BL       ADC_ResetCalibration
;;;84     	while(ADC_GetResetCalibrationStatus(ADC1) == SET){}
00005a  bf00              NOP      
                  |L13.92|
00005c  480e              LDR      r0,|L13.152|
00005e  f7fffffe          BL       ADC_GetResetCalibrationStatus
000062  2801              CMP      r0,#1
000064  d0fa              BEQ      |L13.92|
;;;85     	/* Start ADC1 calibration */
;;;86     	ADC_StartCalibration(ADC1);
000066  480c              LDR      r0,|L13.152|
000068  f7fffffe          BL       ADC_StartCalibration
;;;87     	/* Check the end of ADC1 calibration */
;;;88     	while(ADC_GetCalibrationStatus(ADC1) == SET){}
00006c  bf00              NOP      
                  |L13.110|
00006e  480a              LDR      r0,|L13.152|
000070  f7fffffe          BL       ADC_GetCalibrationStatus
000074  2801              CMP      r0,#1
000076  d0fa              BEQ      |L13.110|
;;;89     
;;;90     	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
000078  2101              MOVS     r1,#1
00007a  4807              LDR      r0,|L13.152|
00007c  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;91     	
;;;92     	// Buffer temizleme işlemi
;;;93     	for(i=0;i<64;i++)
000080  2400              MOVS     r4,#0
000082  e003              B        |L13.140|
                  |L13.132|
;;;94     	buffer[i] = '~';
000084  207e              MOVS     r0,#0x7e
000086  4905              LDR      r1,|L13.156|
000088  5508              STRB     r0,[r1,r4]
00008a  1c64              ADDS     r4,r4,#1              ;93
                  |L13.140|
00008c  2c40              CMP      r4,#0x40              ;93
00008e  dbf9              BLT      |L13.132|
;;;95     	   	   
;;;96     }
000090  b006              ADD      sp,sp,#0x18
000092  bd10              POP      {r4,pc}
;;;97     
                          ENDP

                  |L13.148|
                          DCD      0x40010800
                  |L13.152|
                          DCD      0x40012400
                  |L13.156|
                          DCD      buffer

                          AREA ||i.init_NVIC_for_TIM||, CODE, READONLY, ALIGN=1

                  init_NVIC_for_TIM PROC
;;;124    
;;;125    void init_NVIC_for_TIM()
000000  b508              PUSH     {r3,lr}
;;;126    {
;;;127    	
;;;128    	NVIC_InitTypeDef	NVIC_DEF;
;;;129    
;;;130    	NVIC_DEF.NVIC_IRQChannel = TIM2_IRQn;
000002  201c              MOVS     r0,#0x1c
000004  f88d0000          STRB     r0,[sp,#0]
;;;131    	NVIC_DEF.NVIC_IRQChannelCmd = ENABLE;
000008  2001              MOVS     r0,#1
00000a  f88d0003          STRB     r0,[sp,#3]
;;;132    	NVIC_DEF.NVIC_IRQChannelPreemptionPriority = 2;
00000e  2002              MOVS     r0,#2
000010  f88d0001          STRB     r0,[sp,#1]
;;;133    	NVIC_DEF.NVIC_IRQChannelSubPriority = 2;
000014  f88d0002          STRB     r0,[sp,#2]
;;;134    	
;;;135    	NVIC_Init(&NVIC_DEF);
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       NVIC_Init
;;;136    	
;;;137    }
00001e  bd08              POP      {r3,pc}
;;;138    
                          ENDP


                          AREA ||i.init_RCC_AD5932||, CODE, READONLY, ALIGN=1

                  init_RCC_AD5932 PROC
;;;18     
;;;19     void init_RCC_AD5932()
000000  b510              PUSH     {r4,lr}
;;;20     {
;;;21     	RCC_APB1PeriphClockCmd(SPI2_RCC | RCC_APB1Periph_TIM2, ENABLE);
000002  2101              MOVS     r1,#1
000004  f2440001          MOV      r0,#0x4001
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;22     	RCC_APB2PeriphClockCmd(SPI2_RCC_GPIO | USART1_RCC_GPIO | AD5932_GPIOs_RCC|RCC_APB2Periph_ADC1 | RCC_APB2Periph_AFIO, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  f240200d          MOV      r0,#0x20d
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;23     }
000016  bd10              POP      {r4,pc}
;;;24     
                          ENDP


                          AREA ||i.init_SPI_for_AD5932||, CODE, READONLY, ALIGN=2

                  init_SPI_for_AD5932 PROC
;;;25     
;;;26     void init_SPI_for_AD5932()
000000  b500              PUSH     {lr}
;;;27     {
000002  b087              SUB      sp,sp,#0x1c
;;;28     	GPIO_InitTypeDef GPIO_InitStructure;
;;;29     	SPI_InitTypeDef  SPI_InitStructure;
;;;30     
;;;31     	/* SPI2 MOSI SCK pin configuration */
;;;32     
;;;33     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000004  2018              MOVS     r0,#0x18
000006  f88d001b          STRB     r0,[sp,#0x1b]
;;;34     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d001a          STRB     r0,[sp,#0x1a]
;;;35     	GPIO_InitStructure.GPIO_Pin = SPI2_SCK | SPI2_MOSI;
000010  f44f4020          MOV      r0,#0xa000
000014  f8ad0018          STRH     r0,[sp,#0x18]
;;;36     	
;;;37     	GPIO_Init(SPI2_GPIO, &GPIO_InitStructure);
000018  a906              ADD      r1,sp,#0x18
00001a  4814              LDR      r0,|L16.108|
00001c  f7fffffe          BL       GPIO_Init
;;;38     	
;;;39     
;;;40     	
;;;41     	/* SPI2 configuration -------------------------------------------------------*/
;;;42     	SPI_InitStructure.SPI_Direction 		= SPI_Direction_1Line_Tx;
000020  f44f4040          MOV      r0,#0xc000
000024  f8ad0004          STRH     r0,[sp,#4]
;;;43     	SPI_InitStructure.SPI_DataSize 			= SPI_DataSize_16b;
000028  f44f6000          MOV      r0,#0x800
00002c  f8ad0008          STRH     r0,[sp,#8]
;;;44     	SPI_InitStructure.SPI_CPOL 				= SPI_CPOL_High;
000030  2002              MOVS     r0,#2
000032  f8ad000a          STRH     r0,[sp,#0xa]
;;;45     	SPI_InitStructure.SPI_CPHA 				= SPI_CPHA_1Edge;
000036  2000              MOVS     r0,#0
000038  f8ad000c          STRH     r0,[sp,#0xc]
;;;46     	SPI_InitStructure.SPI_NSS 				= SPI_NSS_Soft;
00003c  f44f7000          MOV      r0,#0x200
000040  f8ad000e          STRH     r0,[sp,#0xe]
;;;47     	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_32;
000044  2020              MOVS     r0,#0x20
000046  f8ad0010          STRH     r0,[sp,#0x10]
;;;48     	SPI_InitStructure.SPI_FirstBit 			= SPI_FirstBit_MSB;
00004a  2000              MOVS     r0,#0
00004c  f8ad0012          STRH     r0,[sp,#0x12]
;;;49     	
;;;50     	SPI_InitStructure.SPI_Mode 				= SPI_Mode_Master;
000050  f44f7082          MOV      r0,#0x104
000054  f8ad0006          STRH     r0,[sp,#6]
;;;51     	
;;;52     	
;;;53     	SPI_Init(SPI2, &SPI_InitStructure);
000058  a901              ADD      r1,sp,#4
00005a  4805              LDR      r0,|L16.112|
00005c  f7fffffe          BL       SPI_Init
;;;54     	
;;;55     	SPI_Cmd(SPI2, ENABLE);
000060  2101              MOVS     r1,#1
000062  4803              LDR      r0,|L16.112|
000064  f7fffffe          BL       SPI_Cmd
;;;56     }
000068  b007              ADD      sp,sp,#0x1c
00006a  bd00              POP      {pc}
;;;57     
                          ENDP

                  |L16.108|
                          DCD      0x40010c00
                  |L16.112|
                          DCD      0x40003800

                          AREA ||i.init_TIM_for_AD5932||, CODE, READONLY, ALIGN=1

                  init_TIM_for_AD5932 PROC
;;;106    
;;;107    void init_TIM_for_AD5932()
000000  b50e              PUSH     {r1-r3,lr}
;;;108    {
;;;109    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;110    
;;;111    	TIM_TimeBaseStructure.TIM_Prescaler = 72; //200kHz e ayarlı
000002  2048              MOVS     r0,#0x48
000004  f8ad0000          STRH     r0,[sp,#0]
;;;112    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
000008  2000              MOVS     r0,#0
00000a  f8ad0002          STRH     r0,[sp,#2]
;;;113    	TIM_TimeBaseStructure.TIM_Period = 4;
00000e  2004              MOVS     r0,#4
000010  f8ad0004          STRH     r0,[sp,#4]
;;;114    	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
000014  2000              MOVS     r0,#0
000016  f8ad0006          STRH     r0,[sp,#6]
;;;115    	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
00001a  f88d0008          STRB     r0,[sp,#8]
;;;116    	
;;;117    	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
00001e  4669              MOV      r1,sp
000020  f04f4080          MOV      r0,#0x40000000
000024  f7fffffe          BL       TIM_TimeBaseInit
;;;118    
;;;119    	TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);
000028  2201              MOVS     r2,#1
00002a  4611              MOV      r1,r2
00002c  0790              LSLS     r0,r2,#30
00002e  f7fffffe          BL       TIM_ITConfig
;;;120    	
;;;121    	TIM_Cmd(TIM2, ENABLE);
000032  2101              MOVS     r1,#1
000034  0788              LSLS     r0,r1,#30
000036  f7fffffe          BL       TIM_Cmd
;;;122    	
;;;123    }
00003a  bd0e              POP      {r1-r3,pc}
;;;124    
                          ENDP


                          AREA ||i.init_USART_for_AD5932||, CODE, READONLY, ALIGN=2

                  init_USART_for_AD5932 PROC
;;;166    
;;;167    void init_USART_for_AD5932()
000000  b500              PUSH     {lr}
;;;168    {
000002  b085              SUB      sp,sp,#0x14
;;;169    	GPIO_InitTypeDef 	GPIO_InitStruct;
;;;170    	USART_InitTypeDef USART_InitStructure;
;;;171    	
;;;172    	GPIO_InitStruct.GPIO_Pin = USART1_Tx;
000004  f44f7000          MOV      r0,#0x200
000008  f8ad0010          STRH     r0,[sp,#0x10]
;;;173    	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP;
00000c  2018              MOVS     r0,#0x18
00000e  f88d0013          STRB     r0,[sp,#0x13]
;;;174    	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
000012  2003              MOVS     r0,#3
000014  f88d0012          STRB     r0,[sp,#0x12]
;;;175    	GPIO_Init(USART1_GPIO, &GPIO_InitStruct);
000018  a904              ADD      r1,sp,#0x10
00001a  480e              LDR      r0,|L18.84|
00001c  f7fffffe          BL       GPIO_Init
;;;176    	
;;;177    	USART_InitStructure.USART_BaudRate = 115200;
000020  f44f30e1          MOV      r0,#0x1c200
000024  9000              STR      r0,[sp,#0]
;;;178    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000026  2000              MOVS     r0,#0
000028  f8ad0004          STRH     r0,[sp,#4]
;;;179    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00002c  f8ad0006          STRH     r0,[sp,#6]
;;;180    	USART_InitStructure.USART_Parity = USART_Parity_No;
000030  f8ad0008          STRH     r0,[sp,#8]
;;;181    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000034  f8ad000c          STRH     r0,[sp,#0xc]
;;;182    	USART_InitStructure.USART_Mode = USART_Mode_Tx;
000038  2008              MOVS     r0,#8
00003a  f8ad000a          STRH     r0,[sp,#0xa]
;;;183    	
;;;184    	USART_Init(USART1,&USART_InitStructure);
00003e  4669              MOV      r1,sp
000040  4805              LDR      r0,|L18.88|
000042  f7fffffe          BL       USART_Init
;;;185    	USART_Cmd(USART1,ENABLE);
000046  2101              MOVS     r1,#1
000048  4803              LDR      r0,|L18.88|
00004a  f7fffffe          BL       USART_Cmd
;;;186    }
00004e  b005              ADD      sp,sp,#0x14
000050  bd00              POP      {pc}
;;;187    
                          ENDP

000052  0000              DCW      0x0000
                  |L18.84|
                          DCD      0x40010800
                  |L18.88|
                          DCD      0x40013800

                          AREA ||i.sendByte_USART||, CODE, READONLY, ALIGN=2

                  sendByte_USART PROC
;;;187    
;;;188    void sendByte_USART(uint8_t data)
000000  b510              PUSH     {r4,lr}
;;;189    {
000002  4604              MOV      r4,r0
;;;190    	while(USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L19.6|
000006  2180              MOVS     r1,#0x80
000008  4804              LDR      r0,|L19.28|
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L19.6|
;;;191    	USART_SendData(USART1,data);
000012  4621              MOV      r1,r4
000014  4801              LDR      r0,|L19.28|
000016  f7fffffe          BL       USART_SendData
;;;192    
;;;193    }
00001a  bd10              POP      {r4,pc}
;;;194    void sendString_USART(const char data[])
                          ENDP

                  |L19.28|
                          DCD      0x40013800

                          AREA ||i.sendCommand_AD5932||, CODE, READONLY, ALIGN=2

                  sendCommand_AD5932 PROC
;;;97     
;;;98     void sendCommand_AD5932(uint16_t comm)
000000  b510              PUSH     {r4,lr}
;;;99     {
000002  4604              MOV      r4,r0
;;;100    	GPIO_ResetBits(GPIOB,SPI2_CS);
000004  f44f5180          MOV      r1,#0x1000
000008  480d              LDR      r0,|L20.64|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;101    	SPI_I2S_SendData(SPI2, comm);
00000e  4621              MOV      r1,r4
000010  480c              LDR      r0,|L20.68|
000012  f7fffffe          BL       SPI_I2S_SendData
;;;102    	while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);
000016  bf00              NOP      
                  |L20.24|
000018  2102              MOVS     r1,#2
00001a  480a              LDR      r0,|L20.68|
00001c  f7fffffe          BL       SPI_I2S_GetFlagStatus
000020  2800              CMP      r0,#0
000022  d0f9              BEQ      |L20.24|
;;;103    	while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_BSY) == SET);
000024  bf00              NOP      
                  |L20.38|
000026  2180              MOVS     r1,#0x80
000028  4806              LDR      r0,|L20.68|
00002a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00002e  2801              CMP      r0,#1
000030  d0f9              BEQ      |L20.38|
;;;104    	GPIO_SetBits(GPIOB,SPI2_CS);
000032  f44f5180          MOV      r1,#0x1000
000036  4802              LDR      r0,|L20.64|
000038  f7fffffe          BL       GPIO_SetBits
;;;105    }
00003c  bd10              POP      {r4,pc}
;;;106    
                          ENDP

00003e  0000              DCW      0x0000
                  |L20.64|
                          DCD      0x40010c00
                  |L20.68|
                          DCD      0x40003800

                          AREA ||i.sendString_USART||, CODE, READONLY, ALIGN=1

                  sendString_USART PROC
;;;193    }
;;;194    void sendString_USART(const char data[])
000000  b510              PUSH     {r4,lr}
;;;195    {
000002  4604              MOV      r4,r0
;;;196    	while(*data)
000004  e003              B        |L21.14|
                  |L21.6|
;;;197    	{
;;;198    		sendByte_USART(*data++);
000006  f8140b01          LDRB     r0,[r4],#1
00000a  f7fffffe          BL       sendByte_USART
                  |L21.14|
00000e  7820              LDRB     r0,[r4,#0]            ;196
000010  2800              CMP      r0,#0                 ;196
000012  d1f8              BNE      |L21.6|
;;;199    	}
;;;200    }
000014  bd10              POP      {r4,pc}
;;;201    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  buffer
                          %        64

                          AREA ||.data||, DATA, ALIGN=1

                  AD5932_Cr
000000  0000              DCW      0x0000
                  AD5932_NumOfInc
000002  0000              DCW      0x0000
                  AD5932_Inc_IntTim
000004  0000              DCB      0x00,0x00
                  buffer_counter
000006  0000              DCB      0x00,0x00
                  adc_value
000008  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "src\\AD5932.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_AD5932_c_e505844a____REV16|
#line 114 ".\\Libraries_USB_STDLIB\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_AD5932_c_e505844a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_AD5932_c_e505844a____REVSH|
#line 128
|__asm___8_AD5932_c_e505844a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
